#pragma once

#include "../string/string_builder.h"

#include "../memory/dynamic_array.h"

#include "specs.h"

CPPU_BEGIN_NAMESPACE

// Note: this won't work if we want CPPU_NO_CRT...
// Figure out a way to replace these functions
#include <stdio.h>
#include <cstdarg>

#if !defined COMPILER_MSVC
#define CPPU_FMT_SNPRINTF snprintf
#else
inline s32 fmt_snprintf(char *buffer, size_t size, const char *format, ...) {
    va_list args;
    va_start(args, format);
    s32 result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);
    va_end(args);
    return result;
}
#define CPPU_FMT_SNPRINTF fmt_snprintf
#endif

namespace fmt::internal {

// Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.
// These are generated by support/compute-powers.py.
inline constexpr u64 POW10_SIGNIFICANDS[] = {
    0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76, 0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d,
    0xe61acf033d1a45df, 0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c, 0x8dd01fad907ffc3c,
    0xd3515c2831559a83, 0x9d71ac8fada6c9b5, 0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
    0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7, 0xa086cfcd97bf97f4, 0xef340a98172aace5,
    0xb23867fb2a35b28e, 0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996, 0xdbac6c247d62a584,
    0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126, 0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
    0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f, 0xf8a95fcf88747d94, 0xb94470938fa89bcf,
    0x8a08f0f8bf0f156b, 0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06, 0xaa242499697392d3,
    0xfd87b5f28300ca0e, 0xbce5086492111aeb, 0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
    0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984, 0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70,
    0xd5d238a4abe98068, 0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8, 0x83c7088e1aab65db,
    0xc45d1df942711d9a, 0x924d692ca61be758, 0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
    0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d, 0x952ab45cfa97a0b3, 0xde469fbd99a05fe3,
    0xa59bc234db398c25, 0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2, 0xcc20ce9bd35c78a5,
    0x98165af37b2153df, 0xe2a0b5dc971f303a, 0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
    0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129, 0xe7109bfba19c0c9d, 0xac2820d9623bf429,
    0x80444b5e7aa7cf85, 0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841, 0x9e19db92b4e31ba9,
    0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
};

// Binary exponents of pow(10, k), for k = -348, -340, ..., 340, corresponding
// to significands above.
inline constexpr s16 POW10_EXPONENTS[] = {
    -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954, -927, -901, -874, -847, -821, -794, -768,
    -741,  -715,  -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502, -475, -449, -422, -396, -369, -343, -316, -289,
    -263,  -236,  -210,  -183,  -157,  -130,  -103,  -77,   -50,   -24,  3,    30,   56,   83,   109,  136,  162,  189,
    216,   242,   269,   295,   322,   348,   375,   402,   428,   455,  481,  508,  534,  561,  588,  614,  641,  667,
    694,   720,   747,   774,   800,   827,   853,   880,   907,   933,  960,  986,  1013, 1039, 1066};

// A handmade floating-point number f * pow(2, e).
class fp {
   private:
    // All sizes are in bits.
    static constexpr s32 CHAR_SIZE = std::numeric_limits<byte>::digits;
    // Subtract 1 to account for an implicit most significant bit in the
    // normalized form.
    static constexpr s32 DOUBLE_SIGNIFICAND_SIZE = std::numeric_limits<f64>::digits - 1;
    static constexpr u64 IMPLICIT_BIT = 1ull << DOUBLE_SIGNIFICAND_SIZE;

   public:
    u64 f;
    s32 e;

    static constexpr s32 SIGNIFICAND_SIZE = sizeof(u64) * CHAR_SIZE;

    fp() : f(0), e(0) {}
    fp(uint64_t f, s32 e) : f(f), e(e) {}

    // Constructs fp from an IEEE754 double. It is a template to prevent compile
    // errors on platforms where double is not IEEE754.
    // Assumes double is in the format [sign][exponent][significand].
    template <typename Double>
    explicit fp(Double d) {
        using limits = std::numeric_limits<Double>;

        u64 u;
        copy_memory(&u, &d, sizeof(u64));

        u64 significandMask = IMPLICIT_BIT - 1;
        u64 exponentMask = (~0ull >> 1) & ~significandMask;
        auto biasedExponent = (u & exponentMask) >> DOUBLE_SIGNIFICAND_SIZE;
        f = u & significandMask;
        if (biasedExponent != 0) {
            f += IMPLICIT_BIT;
        } else {
            biasedExponent = 1;  // Subnormals use biased exponent 1 (min exponent).
        }

        s32 exponentSize = (s32)(sizeof(Double) * CHAR_SIZE) - DOUBLE_SIGNIFICAND_SIZE - 1;  // -1 for sign
        s32 exponentBias = (1 << exponentSize) - limits::max_exponent - 1;
        e = (s32)(biasedExponent - exponentBias - DOUBLE_SIGNIFICAND_SIZE);
    }

    // Normalizes the value converted from double and multiplied by (1 << SHIFT).
    template <s32 Shift = 0>
    void normalize() {
        // Handle subnormals.
        auto shiftedImplicitBit = IMPLICIT_BIT << Shift;
        while ((f & shiftedImplicitBit) == 0) {
            f <<= 1;
            --e;
        }

        // Subtract 1 to account for hidden bit.
        auto offset = SIGNIFICAND_SIZE - DOUBLE_SIGNIFICAND_SIZE - Shift - 1;
        f <<= offset;
        e -= offset;
    }

    // Compute lower and upper boundaries (m^- and m^+ in the Grisu paper), where
    // a boundary is a value half way between the number and its predecessor
    // (lower) or successor (upper). The upper boundary is normalized and lower
    // has the same exponent but may be not normalized.
    void compute_boundaries(fp &lower, fp &upper) const {
        lower = f == IMPLICIT_BIT ? fp((f << 2) - 1, e - 2) : fp((f << 1) - 1, e - 1);
        upper = fp((f << 1) + 1, e - 1);
        upper.normalize<1>();  // 1 is to account for the exponent shift above.
        lower.f <<= lower.e - upper.e;
        lower.e = upper.e;
    }

    // Returns an fp number representing x - y. Result may not be normalized.
    inline fp operator-(fp other) {
        assert(f >= other.f && e == other.e);
        return fp(f - other.f, e);
    }

    // Computes an fp number r with r.f = x.f * y.f / pow(2, 64) rounded to nearest
    // with half-up tie breaking, r.e = x.e + y.e + 64. Result may not be normalized.
    inline fp operator*(fp other) {
        // Multiply 32-bit parts of significands.
        u64 mask = (1ULL << 32) - 1;
        u64 a = f >> 32, b = f & mask;
        u64 c = other.f >> 32, d = other.f & mask;
        u64 ac = a * c, bc = b * c, ad = a * d, bd = b * d;
        // Compute mid 64-bit of result and round.
        u64 mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
        return fp(ac + (ad >> 32) + (bc >> 32) + (mid >> 32), e + other.e + 64);
    }
};

// Returns cached power (of 10) c_k = c_k.f * pow(2, c_k.e) such that its
// (binary) exponent satisfies min_exponent <= c_k.e <= min_exponent + 3.
inline fp get_cached_power(s32 minExponent, s32 &pow10Exp) {
    constexpr double ONE_OVER_LOG2_10 = 0.30102999566398114;  // 1 / log2(10)

    s32 index = (s32)(std::ceil((minExponent + fp::SIGNIFICAND_SIZE - 1) * ONE_OVER_LOG2_10));
    // Decimal exponent of the first (smallest) cached power of 10.
    constexpr s32 FIRST_DEC_EXP = -348;
    // Difference between 2 consecutive decimal exponents in cached powers of 10.
    constexpr s32 DEC_EXP_STEP = 8;
    index = (index - FIRST_DEC_EXP - 1) / DEC_EXP_STEP + 1;
    pow10Exp = FIRST_DEC_EXP + index * DEC_EXP_STEP;
    return fp(POW10_SIGNIFICANDS[index], POW10_EXPONENTS[index]);
}

inline b32 grisu2_round(char *buffer, size_t &size, size_t maxDigits, u64 delta, u64 remainder, u64 exp, u64 diff,
                        s32 &exp10) {
    while (remainder < diff && delta - remainder >= exp &&
           (remainder + exp < diff || diff - remainder > remainder + exp - diff)) {
        --buffer[size - 1];
        remainder += exp;
    }
    if (size > maxDigits) {
        --size;
        ++exp10;
        if (buffer[size] >= '5') return false;
    }
    return true;
}

// Generates output using Grisu2 digit-gen algorithm.
inline b32 grisu2_gen_digits(char *buffer, size_t &size, u32 hi, u64 lo, s32 &exp, u64 delta, const fp &one,
                             const fp &diff, size_t maxDigits) {
    // Generate digits for the most significant part (hi).
    while (exp > 0) {
        u32 digit = 0;
        // This optimization by miloyip reduces the number of integer divisions by
        // one per iteration.
        switch (exp) {
            case 10:
                digit = hi / 1000000000;
                hi %= 1000000000;
                break;
            case 9:
                digit = hi / 100000000;
                hi %= 100000000;
                break;
            case 8:
                digit = hi / 10000000;
                hi %= 10000000;
                break;
            case 7:
                digit = hi / 1000000;
                hi %= 1000000;
                break;
            case 6:
                digit = hi / 100000;
                hi %= 100000;
                break;
            case 5:
                digit = hi / 10000;
                hi %= 10000;
                break;
            case 4:
                digit = hi / 1000;
                hi %= 1000;
                break;
            case 3:
                digit = hi / 100;
                hi %= 100;
                break;
            case 2:
                digit = hi / 10;
                hi %= 10;
                break;
            case 1:
                digit = hi;
                hi = 0;
                break;
            default:
                assert(false && "Invalid number of digits");
        }
        if (digit != 0 || size != 0) buffer[size++] = (char) ('0' + digit);
        --exp;
        u64 remainder = ((u64) hi << -one.e) + lo;
        if (remainder <= delta || size > maxDigits) {
            return grisu2_round(buffer, size, maxDigits, delta, remainder, (u64)(POWERS_OF_10_32[exp]) << -one.e,
                                diff.f, exp);
        }
    }

    // Generate digits for the least significant part (lo).
    for (;;) {
        lo *= 10;
        delta *= 10;
        char digit = (char) (lo >> -one.e);
        if (digit != 0 || size != 0) buffer[size++] = (char) ('0' + digit);
        lo &= one.f - 1;
        --exp;
        if (lo < delta || size > maxDigits) {
            return grisu2_round(buffer, size, maxDigits, delta, lo, one.f, diff.f * POWERS_OF_10_32[-exp], exp);
        }
    }
}

struct Gen_Digits_Params {
    u32 NumDigits = 0;
    bool Fixed = false;
    bool Upper = false;
    bool TrailingZeros = false;
};

struct Prettify_Handler {
    char *Data;
    size_t &Size;

    Prettify_Handler(char *data, size_t &size) : Data(data), Size(size) {}

    template <typename F>
    void insert(size_t pos, size_t n, F f) {
        move_memory(Data + pos + n, Data + pos, Size - pos);
        f(Data + pos);
        Size += n;
    }

    void insert(size_t pos, char c) {
        move_memory(Data + pos + 1, Data + pos, Size - pos);
        Data[pos] = c;
        ++Size;
    }

    void append(size_t n, char c) {
        char *p = Data + Size;
        for (auto _ : range(n)) {
            *p++ = c;
        }
        Size += n;
    }

    void append(char c) { Data[Size++] = c; }

    void remove_trailing(char c) {
        while (Data[Size - 1] == c) --Size;
    }
};

// Writes the exponent exp in the form "[+-]d{2,3}" to buffer.
template <typename Handler>
void write_exponent(s32 exp, Handler &&h) {
    assert(-1000 < exp && exp < 1000 && "Exponent out of range");
    if (exp < 0) {
        h.append('-');
        exp = -exp;
    } else {
        h.append('+');
    }
    if (exp >= 100) {
        h.append((char) ('0' + exp / 100));
        exp %= 100;

        const char *d = DIGITS + exp * 2;
        h.append(d[0]);
        h.append(d[1]);
    } else {
        const char *d = DIGITS + exp * 2;
        h.append(d[0]);
        h.append(d[1]);
    }
}

struct Fill {
    size_t n;

    void operator()(char *buffer) const {
        buffer[0] = '0';
        buffer[1] = '.';

        char *p = buffer + 2;
        for (auto _ : range(n)) {
            *p++ = '0';
        }
    }
};

// The number is given as v = f * pow(10, exp), where f has size digits.
template <typename Handler>
void grisu2_prettify(const Gen_Digits_Params &params, size_t size, s32 exp, Handler &&handler) {
    if (!params.Fixed) {
        // Insert a decimal point after the first digit and add an exponent.
        handler.insert(1, '.');
        exp += (s32) size - 1;
        if (size < params.NumDigits) handler.append(params.NumDigits - size, '0');
        handler.append(params.Upper ? 'E' : 'e');
        write_exponent(exp, handler);
        return;
    }

    // pow(10, fullExp - 1) <= v <= pow(10, fullExp).
    s32 intSize = (s32) size;
    s32 fullExp = intSize + exp;
    if (intSize <= fullExp && fullExp <= 21) {
        // 1234e7 -> 12340000000[.0+]
        handler.append(fullExp - intSize, '0');
        s32 numZeros = (s32) params.NumDigits - fullExp;
        if (numZeros > 0 && params.TrailingZeros) {
            handler.append('.');
            handler.append(numZeros, '0');
        }
    } else if (fullExp > 0) {
        // 1234e-2 -> 12.34[0+]
        handler.insert(fullExp, '.');
        if (!params.TrailingZeros) {
            // Remove trailing zeros.
            handler.remove_trailing('0');
        } else if (params.NumDigits > size) {
            // Add trailing zeros.
            handler.append(params.NumDigits - size, '0');
        }
    } else {
        // 1234e-6 -> 0.001234
        handler.insert(0, 2 - fullExp, Fill{to_unsigned(-fullExp)});
    }
}

// Uses to determine how much space to reserve in the buffer when formatting.
struct Char_Counter {
    size_t Size;

    template <typename F>
    void insert(size_t, size_t n, F) {
        Size += n;
    }
    void insert(size_t, char) { ++Size; }
    void append(size_t n, char) { Size += n; }
    void append(char) { ++Size; }
    void remove_trailing(char) {}
};

// Converts format specifiers into parameters for digit generation and computes
// output buffer size for a number in the range [pow(10, exp - 1), pow(10, exp)
// or 0 if exp == 1.
inline Gen_Digits_Params process_specs(const Format_Specs &specs, s32 exp, Dynamic_Array<char> &buffer) {
    Gen_Digits_Params params;
    s32 numDigits = specs.Precision >= 0 ? specs.Precision : 6;
    switch (specs.Type) {
        case 'G':
            params.Upper = true;
            [[fallthrough]];
        case 'g':
            params.TrailingZeros = ((u32) specs.Flags & (u32) Flag::HASH) != 0;
            if (-4 <= exp && exp < numDigits + 1) {
                params.Fixed = true;
                if (!specs.Type && params.TrailingZeros && exp >= 0) numDigits = exp + 1;
            }
            break;
        case '\0':
        case 'F':
            params.Upper = true;
            [[fallthrough]];
        case 'f': {
            params.Fixed = true;
            params.TrailingZeros = true;
            s32 adjustedMinDigits = numDigits + exp;
            if (adjustedMinDigits > 0) numDigits = adjustedMinDigits;
            break;
        }
        case 'E':
            params.Upper = true;
            [[fallthrough]];
        case 'e':
            ++numDigits;
            break;
    }
    params.NumDigits = to_unsigned(numDigits);
    Char_Counter counter{params.NumDigits};
    grisu2_prettify(params, params.NumDigits, exp - numDigits, counter);
    buffer._reserve(counter.Size);
    return params;
}

template <typename Double>
typename std::enable_if_t<sizeof(Double) == sizeof(u64), b32> grisu2_format(Double value, Dynamic_Array<char> &buffer,
                                                                            const Format_Specs &specs) {
    assert(value >= 0 && "Value is negative");
    if (value == 0) {
        Gen_Digits_Params params = process_specs(specs, 1, buffer);
        size_t size = 1;
        buffer[0] = '0';
        grisu2_prettify(params, size, 0, Prettify_Handler(buffer.Data, buffer.Count));
        return true;
    }

    fp fpValue(value);
    fp lower, upper;  // w^- and w^+ in the Grisu paper.
    fpValue.compute_boundaries(lower, upper);

    // Find a cached power of 10 close to 1 / upper and use it to scale upper.
    s32 minExp = -60;                   // alpha in Grisu.
    s32 cachedExp = 0;                  // K in Grisu.
    auto cachedPow = get_cached_power(  // \tilde{c}_{-k} in Grisu.
        minExp - (upper.e + fp::SIGNIFICAND_SIZE), cachedExp);
    cachedExp = -cachedExp;
    upper = upper * cachedPow;  // \tilde{M}^+ in Grisu.
    --upper.f;                  // \tilde{M}^+ - 1 ulp -> M^+_{\downarrow}.

    fp one(1ull << -upper.e, upper.e);
    // hi (p1 in Grisu) contains the most significant digits of scaled_upper.
    // hi = floor(upper / one).
    u32 hi = (u32)(upper.f >> -one.e);
    s32 exp = (s32) count_digits(hi);  // kappa in Grisu.

    Gen_Digits_Params params = process_specs(specs, cachedExp + exp, buffer);
    fpValue.normalize();
    fp scaledValue = fpValue * cachedPow;
    lower = lower * cachedPow;  // \tilde{M}^- in Grisu.
    ++lower.f;                  // \tilde{M}^- + 1 ulp -> M^-_{\uparrow}.

    u64 delta = upper.f - lower.f;
    fp diff = upper - scaledValue;  // wp_w in Grisu.
    // lo (p2 in Grisu) contains the least significants digits of scaled_upper.
    // lo = supper % one.
    u64 lo = upper.f & (one.f - 1);
    size_t &size = buffer.Count;
    if (!grisu2_gen_digits(buffer.Data, size, hi, lo, exp, delta, one, diff, params.NumDigits)) {
        buffer.release();
        return false;
    }
    grisu2_prettify(params, size, cachedExp + exp, Prettify_Handler(buffer.Data, buffer.Count));
    return true;
}

template <typename Double>
void sprintf_format(Double value, Dynamic_Array<char> &buffer, const Format_Specs &specs) {
    process_specs(specs, 1, buffer);

    // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.
    assert(buffer._Reserved != 0);

    // Build format string.
    char format[10];  // longest format: %#-*.*Lg
    char *formatPtr = format;
    *formatPtr++ = '%';
    if (specs.has_flag(Flag::HASH)) *formatPtr++ = '#';
    if (specs.Precision >= 0) {
        *formatPtr++ = '.';
        *formatPtr++ = '*';
    }
    *formatPtr++ = (char) specs.Type;
    *formatPtr = '\0';

    // Format using snprintf.
    char *start = null;
    for (;;) {
        size_t bufferSize = buffer._Reserved;
        start = &buffer[0];

        s32 result = specs.Precision < 0 ? CPPU_FMT_SNPRINTF(start, bufferSize, format, value)
                                         : CPPU_FMT_SNPRINTF(start, bufferSize, format, specs.Precision, value);
        if (result >= 0) {
            u32 n = to_unsigned(result);
            if (n < buffer._Reserved) {
                // The buffer was large enough
                buffer.Count = n;
                break;
            }
            buffer._reserve(n + 1);
        } else {
            buffer._reserve(buffer._Reserved + 1);
        }
    }
}
}  // namespace fmt::internal

#undef CPPU_FMT_SNPRINTF

CPPU_END_NAMESPACE