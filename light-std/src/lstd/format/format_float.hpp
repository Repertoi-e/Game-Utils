#pragma once

#include "../string/string_builder.hpp"

#include "../memory/memory_buffer.hpp"

#include "../io/writer.hpp"

#include "format_integer.hpp"

#include "specs.hpp"

#include <cstdarg>

#if !defined LSTD_NO_CRT
#include <stdio.h>
#endif

LSTD_BEGIN_NAMESPACE

#if COMPILER == MSVC
#if !defined LSTD_NO_CRT
inline s32 fmt_snprintf(char *buffer, size_t size, const char *format, ...) {
    va_list args;
    va_start(args, format);
    s32 result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);
    va_end(args);
    return result;
}
#define LSTD_FMT_SNPRINTF fmt_snprintf
#else
// We don't use vsnprintf_s since we aren't linking with the runtime library...
#define LSTD_FMT_SNPRINTF(buffer, size, ...) (s32) size
#endif
#else
#define LSTD_FMT_SNPRINTF snprintf
#endif

namespace fmt::internal {

// Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.
// These are generated by support/compute-powers.py.
inline constexpr u64 POW10_SIGNIFICANDS[] = {
    0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76, 0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d,
    0xe61acf033d1a45df, 0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c, 0x8dd01fad907ffc3c,
    0xd3515c2831559a83, 0x9d71ac8fada6c9b5, 0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
    0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7, 0xa086cfcd97bf97f4, 0xef340a98172aace5,
    0xb23867fb2a35b28e, 0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996, 0xdbac6c247d62a584,
    0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126, 0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
    0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f, 0xf8a95fcf88747d94, 0xb94470938fa89bcf,
    0x8a08f0f8bf0f156b, 0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06, 0xaa242499697392d3,
    0xfd87b5f28300ca0e, 0xbce5086492111aeb, 0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
    0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984, 0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70,
    0xd5d238a4abe98068, 0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8, 0x83c7088e1aab65db,
    0xc45d1df942711d9a, 0x924d692ca61be758, 0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
    0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d, 0x952ab45cfa97a0b3, 0xde469fbd99a05fe3,
    0xa59bc234db398c25, 0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2, 0xcc20ce9bd35c78a5,
    0x98165af37b2153df, 0xe2a0b5dc971f303a, 0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
    0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129, 0xe7109bfba19c0c9d, 0xac2820d9623bf429,
    0x80444b5e7aa7cf85, 0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841, 0x9e19db92b4e31ba9,
    0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
};

// Binary exponents of pow(10, k), for k = -348, -340, ..., 340, corresponding
// to significands above.
inline constexpr s16 POW10_EXPONENTS[] = {
    -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954, -927, -901, -874, -847, -821, -794, -768,
    -741,  -715,  -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502, -475, -449, -422, -396, -369, -343, -316, -289,
    -263,  -236,  -210,  -183,  -157,  -130,  -103,  -77,   -50,   -24,  3,    30,   56,   83,   109,  136,  162,  189,
    216,   242,   269,   295,   322,   348,   375,   402,   428,   455,  481,  508,  534,  561,  588,  614,  641,  667,
    694,   720,   747,   774,   800,   827,   853,   880,   907,   933,  960,  986,  1013, 1039, 1066};

// A handmade floating-point number f * pow(2, e).
class fp {
   private:
    // All sizes are in bits.
    static constexpr s32 CHAR_SIZE = std::numeric_limits<byte>::digits;
    // Subtract 1 to account for an implicit most significant bit in the
    // normalized form.
    static constexpr s32 DOUBLE_SIGNIFICAND_SIZE = std::numeric_limits<f64>::digits - 1;
    static constexpr u64 IMPLICIT_BIT = 1ull << DOUBLE_SIGNIFICAND_SIZE;

   public:
    u64 f;
    s32 e;

    static constexpr s32 SIGNIFICAND_SIZE = sizeof(u64) * CHAR_SIZE;

    fp() : f(0), e(0) {}
    fp(uint64_t f, s32 e) : f(f), e(e) {}

    // Constructs fp from an IEEE754 double. It is a template to prevent compile
    // errors on platforms where double is not IEEE754.
    // Assumes double is in the format [sign][exponent][significand].
    template <typename Double>
    explicit fp(Double d) {
        using limits = std::numeric_limits<Double>;

        u64 u;
        copy_memory(&u, &d, sizeof(u64));

        u64 significandMask = IMPLICIT_BIT - 1;
        u64 exponentMask = (~0ull >> 1) & ~significandMask;
        auto biasedExponent = (u & exponentMask) >> DOUBLE_SIGNIFICAND_SIZE;
        f = u & significandMask;
        if (biasedExponent != 0) {
            f += IMPLICIT_BIT;
        } else {
            biasedExponent = 1;  // Subnormals use biased exponent 1 (min exponent).
        }

        s32 exponentSize = (s32)(sizeof(Double) * CHAR_SIZE) - DOUBLE_SIGNIFICAND_SIZE - 1;  // -1 for sign
        s32 exponentBias = (1 << exponentSize) - limits::max_exponent - 1;
        e = (s32)(biasedExponent - exponentBias - DOUBLE_SIGNIFICAND_SIZE);
    }

    // Normalizes the value converted from double and multiplied by (1 << SHIFT).
    template <s32 Shift = 0>
    void normalize() {
        // Handle subnormals.
        auto shiftedImplicitBit = IMPLICIT_BIT << Shift;
        while ((f & shiftedImplicitBit) == 0) {
            f <<= 1;
            --e;
        }

        // Subtract 1 to account for hidden bit.
        auto offset = SIGNIFICAND_SIZE - DOUBLE_SIGNIFICAND_SIZE - Shift - 1;
        f <<= offset;
        e -= offset;
    }

    // Compute lower and upper boundaries (m^- and m^+ in the Grisu paper), where
    // a boundary is a value half way between the number and its predecessor
    // (lower) or successor (upper). The upper boundary is normalized and lower
    // has the same exponent but may be not normalized.
    void compute_boundaries(fp &lower, fp &upper) const {
        lower = f == IMPLICIT_BIT ? fp((f << 2) - 1, e - 2) : fp((f << 1) - 1, e - 1);
        upper = fp((f << 1) + 1, e - 1);
        upper.normalize<1>();  // 1 is to account for the exponent shift above.
        lower.f <<= lower.e - upper.e;
        lower.e = upper.e;
    }

    // Returns an fp number representing x - y. Result may not be normalized.
    inline fp operator-(fp other) {
        assert(f >= other.f && e == other.e);
        return fp(f - other.f, e);
    }

    // Computes an fp number r with r.f = x.f * y.f / pow(2, 64) rounded to nearest
    // with half-up tie breaking, r.e = x.e + y.e + 64. Result may not be normalized.
    inline fp operator*(fp other) {
        // Multiply 32-bit parts of significands.
        u64 mask = (1ULL << 32) - 1;
        u64 a = f >> 32, b = f & mask;
        u64 c = other.f >> 32, d = other.f & mask;
        u64 ac = a * c, bc = b * c, ad = a * d, bd = b * d;
        // Compute mid 64-bit of result and round.
        u64 mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
        return fp(ac + (ad >> 32) + (bc >> 32) + (mid >> 32), e + other.e + 64);
    }
};

inline s32 my_ceil(f32 num) {
    s32 inum = (s32) num;
    if (num == (f32) inum) {
        return inum;
    }
    return inum + 1;
}

// Returns cached power (of 10) c_k = c_k.f * pow(2, c_k.e) such that its
// (binary) exponent satisfies minExponent <= c_k.e <= minExponent + 3.
inline fp get_cached_power(s32 minExponent, s32 *pow10Exp) {
    constexpr f32 ONE_OVER_LOG2_10 = (f32) 0.30102999566398114;  // 1 / log2(10)

    s32 index = my_ceil((minExponent + fp::SIGNIFICAND_SIZE - 1) * ONE_OVER_LOG2_10);
    // Decimal exponent of the first (smallest) cached power of 10.
    constexpr s32 FIRST_DEC_EXP = -348;
    // Difference between 2 consecutive decimal exponents in cached powers of 10.
    constexpr s32 DEC_EXP_STEP = 8;
    index = (index - FIRST_DEC_EXP - 1) / DEC_EXP_STEP + 1;
    *pow10Exp = FIRST_DEC_EXP + index * DEC_EXP_STEP;
    return fp(POW10_SIGNIFICANDS[index], POW10_EXPONENTS[index]);
}

// Stopping condition for the fixed precision.
struct Fixed_Stop {
    s32 Precision;
    s32 Exp10;
    bool Fixed;

    void on_exp(s32 exp) {
        if (!Fixed) return;
        exp += Exp10;
        if (exp >= 0) {
            Precision += exp;
        }
    }

    bool operator()(byte *, s32 *size, u64 remainder, u64 divisor, u64 error, s32 *, bool integral) {
        assert(remainder < divisor);

        if (*size != Precision) return false;

        if (!integral) {
            // Check if error * 2 < divisor with overflow prevention.
            // The check is not needed for the integral part because error = 1
            // and divisor > (1 << 32) there.
            if (error >= divisor || error >= divisor - error) {
                *size = -1;
                return true;
            }
        } else {
            assert(error == 1 && divisor > 2);
        }
        // Round down if (remainder + error) * 2 <= divisor.
        if (remainder < divisor - remainder && error * 2 <= divisor - remainder * 2) return true;

        // TODO: round up
        *size = -1;
        return true;
    }
};

// Stopping condition for the shortest representation.
struct Shortest_Stop {
    fp Diff;  // wp_w in Grisu.

    void on_exp(s32 exp) {}

    bool operator()(byte *buffer, s32 *size, u64 remainder, u64 divisor, u64 error, s32 *exp, bool integral) {
        if (remainder > error) return false;

        u64 d = integral ? Diff.f : Diff.f * POWERS_OF_10_64[-(*exp)];
        while (remainder < d && error - remainder >= divisor &&
               (remainder + divisor < d || d - remainder > remainder + divisor - d)) {
            --buffer[*size - 1];
            remainder += divisor;
        }
        return true;
    }
};

// Generates output using Grisu2 digit-gen algorithm.
template <typename Stop>
inline s32 grisu2_gen_digits(byte *buffer, fp value, u64 errorUlp, s32 *exp, Stop stop) {
    fp one(1ull << -value.e, value.e);
    // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
    // zero because it contains a product of two 64-bit numbers with MSB set (due
    // to normalization) - 1, shifted right by at most 60 bits.
    auto integral = (u32)(value.f >> -one.e);
    assert(integral != 0);
    assert(integral == value.f >> -one.e);

    // The fractional part of scaled value (p2 in Grisu) c = value % one.
    u64 fractional = value.f & (one.f - 1);
    *exp = count_digits(integral);  // kappa in Grisu.
    stop.on_exp(*exp);

    // Generate digits for the integral part. This can produce up to 10 digits.
    s32 size = 0;
    do {
        u32 digit = 0;
        switch (*exp) {
            case 10:
                digit = integral / 1000000000;
                integral %= 1000000000;
                break;
            case 9:
                digit = integral / 100000000;
                integral %= 100000000;
                break;
            case 8:
                digit = integral / 10000000;
                integral %= 10000000;
                break;
            case 7:
                digit = integral / 1000000;
                integral %= 1000000;
                break;
            case 6:
                digit = integral / 100000;
                integral %= 100000;
                break;
            case 5:
                digit = integral / 10000;
                integral %= 10000;
                break;
            case 4:
                digit = integral / 1000;
                integral %= 1000;
                break;
            case 3:
                digit = integral / 100;
                integral %= 100;
                break;
            case 2:
                digit = integral / 10;
                integral %= 10;
                break;
            case 1:
                digit = integral;
                integral = 0;
                break;
            default:
                assert(false && "invalid number of digits");
        }
        buffer[size++] = (byte)('0' + digit);
        --*exp;
        auto remainder = ((u64) integral << -one.e) + fractional;
        if (stop(buffer, &size, remainder, POWERS_OF_10_64[*exp] << -one.e, errorUlp, exp, true)) return size;
    } while (*exp > 0);

    // Generate digits for the fractional part.
    while (true) {
        fractional *= 10;
        errorUlp *= 10;
        buffer[size++] = (byte)('0' + (byte)(fractional >> -one.e));
        fractional &= one.f - 1;
        --*exp;
        if (stop(buffer, &size, fractional, one.f, errorUlp, exp, false)) return size;
    }
}

// Writes the exponent exp in the form "[+-]d{2,3}" to buffer.
inline void write_exponent(s32 exp, io::Writer &writer) {
    assert(-1000 < exp && exp < 1000 && "Exponent out of range");
    if (exp < 0) {
        writer.write_codepoint('-');
        exp = -exp;
    } else {
        writer.write_codepoint('+');
    }
    if (exp >= 100) {
        writer.write_codepoint('0' + exp / 100);
        exp %= 100;
        const byte *d = DIGITS + exp * 2;
        writer.write_codepoint(d[0]);
        writer.write_codepoint(d[1]);
    } else {
        const byte *d = DIGITS + exp * 2;
        if (d[0] != '0') writer.write_codepoint(d[0]);
        writer.write_codepoint(d[1]);
    }
}

template <size_t S>
bool grisu2_format(f64 value, Memory_Buffer<S> &buffer, s32 precision, bool fixed, s32 *exp) {
    assert(value >= 0 && "Value is negative");
    if (value == 0) {
        if (precision < 0) {
            buffer[0] = '0';
            *exp = 0;
            buffer.ByteLength = 1;
        } else {
            *exp = -precision;
            buffer.reserve(precision);
            fill_memory(buffer.Data, '0', precision);
            buffer.ByteLength = precision;
        }
        return true;
    }

    fp fpValue(value);
    s32 minExp = -60;     // alpha in Grisu.
    s32 cachedExp10 = 0;  // K in Grisu.
    if (precision != -1) {
        if (precision > 17) return false;
        fpValue.normalize();
        fpValue = fpValue * get_cached_power(minExp - (fpValue.e + fp::SIGNIFICAND_SIZE), &cachedExp10);
        s32 size = grisu2_gen_digits(buffer.Data, fpValue, 1, exp, Fixed_Stop{precision, -cachedExp10, fixed});
        if (size < 0) return false;
        buffer.ByteLength = size;
    } else {
        fp lower, upper;  // w^- and w^+ in the Grisu paper.
        fpValue.compute_boundaries(lower, upper);

        // Find a cached power of 10 such that multiplying upper by it will bring
        // the exponent in the range [minExp, -32].
        auto cachedPow =
            get_cached_power(minExp - (upper.e + fp::SIGNIFICAND_SIZE), &cachedExp10);  // \tilde{c}_{-k} in Grisu.
        upper = upper * cachedPow;                                                      // \tilde{M}^+ in Grisu.
        --upper.f;  // \tilde{M}^+ - 1 ulp -> M^+_{\downarrow}.
        assert(minExp <= upper.e && upper.e <= -32);
        fpValue.normalize();
        fpValue = fpValue * cachedPow;
        lower = lower * cachedPow;  // \tilde{M}^- in Grisu.
        ++lower.f;                  // \tilde{M}^- + 1 ulp -> M^-_{\uparrow}.
        s32 size = grisu2_gen_digits(buffer.Data, upper, upper.f - lower.f, exp, Shortest_Stop{upper - fpValue});
        if (size < 0) return false;
        buffer.ByteLength = size;
    }
    *exp -= cachedExp10;
    return true;
}

// The number is given as v = digits * pow(10, exp).
inline void grisu2_prettify(byte *digits, s32 size, s32 exp, io::Writer &writer, bool upper, s32 numDigits,
                            bool trailingZeros) {
    // pow(10, fullExp - 1) <= v <= pow(10, fullExp).
    s32 fullExp = size + exp;

    u32 NumDigits = 0;

    bool fixed = (fullExp - 1) >= -4 && (fullExp - 1) <= 10;
    if (!fixed) {
        // Insert a decimal point after the first digit and add an exponent.
        writer.write_codepoint(*digits);
        if (size > 1) writer.write_codepoint('.');
        exp += size - 1;
        writer.write(digits + 1, size - 1);
        if (size < numDigits) {
            For(range(numDigits - size)) writer.write_codepoint('0');
        }
        writer.write_codepoint(upper ? 'E' : 'e');
        write_exponent(exp, writer);
        return;
    }

    if (size <= fullExp && fullExp <= 21) {
        // 1234e7 -> 12340000000[.0+]
        writer.write(digits + 1, size - 1);
        For(range(fullExp - size)) writer.write_codepoint('0');

        int numZeros = max(numDigits - fullExp, 1);
        if (trailingZeros) {
            writer.write_codepoint('.');
            For(range(numZeros)) writer.write_codepoint('0');
        }
    } else if (fullExp > 0) {
        // 1234e-2 -> 12.34[0+]
        writer.write(digits, fullExp);
        writer.write_codepoint('.');
        writer.write(digits + fullExp, size - fullExp);
        if (!trailingZeros) {
            writer.remove_trailing_bytes('0');
        } else if (numDigits > size) {
            For(range(numDigits - size)) writer.write_codepoint('0');
        }
    } else {
        // 1234e-6 -> 0.001234
        writer.write_codepoint('0');
        writer.write_codepoint('.');
        For(range(-fullExp)) writer.write_codepoint('0');
        writer.write(digits, size);
    }
}

template <typename Double, size_t S>
void sprintf_format(Double value, Memory_Buffer<S> &buffer, const Format_Specs &specs) {
    process_specs(specs, 1, buffer);

    // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.
    assert(buffer.get_capacity() != 0);

    // Build format string.
    byte format[10];  // longest format: %#-*.*Lg
    byte *formatPtr = format;
    *formatPtr++ = '%';
    if (specs.has_flag(Flag::HASH)) *formatPtr++ = '#';
    if (specs.Precision >= 0) {
        *formatPtr++ = '.';
        *formatPtr++ = '*';
    }
    *formatPtr++ = (byte) specs.Type;
    *formatPtr = '\0';

    // Format using snprintf.
    byte *start = null;
    while (true) {
        size_t bufferSize = buffer.get_capacity();
        start = buffer.Data;

        s32 result = specs.Precision < 0
                         ? LSTD_FMT_SNPRINTF((char *) start, bufferSize, (char *) format, value)
                         : LSTD_FMT_SNPRINTF((char *) start, bufferSize, (char *) format, specs.Precision, value);
        if (result >= 0) {
            u32 n = to_unsigned(result);
            if (n < buffer.get_capacity()) {
                // The buffer was large enough
                buffer.ByteLength = n;
                break;
            }
            buffer.reserve(n + 1);
        } else {
            buffer.grow(1);
        }
    }
}
}  // namespace fmt::internal

#undef LSTD_FMT_SNPRINTF

LSTD_END_NAMESPACE